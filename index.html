library(tidyverse)
#Tidy Census is the library that connects to the Census API and allows you to pull the data
library(tidycensus)
# GGPLOT2 is one of the most popular data visualization packages.  You can make maps and anytype of plot you might want
library(ggplot2)
# Hmisc is another library that helps with the data manipulation
library(Hmisc)
# SF is the simple features library that allows you work with the spatial datatype of simple features
library(sf)
# Leaflet Gives the base map
library(leaflet)
# Stringr
library(stringr)
# Allows us to export our leaflet map
library(htmlwidgets)
library(dplyr)
library(purrr)
### Part 1 Finding your Census Variables
# First you will need to install your census api
# The census API should have been gotten from https://api.census.gov/data/key_signup.html
# using the census_api_key function here put in your api key.  
# If you want to not have to do this every time you want to download census data, then add the second argument of install=TRUE.  If you choose this, then you might need to restart R. 
census_api_key("c71d4a278773ff7ad70c454369b1851f935b1a34")
#alternative would be census_api_key("YOUR API KEY GOES HERE", install=TRUE)


# Smaller Defined Spatial Unit Example ------------------------------------
Variables<-c(MHI = "B19013_001", # Median Household Income
              MHV = "B25077_001", # Median Home Value
              Totalpop = "B01003_001",# Total Population
             TotHouse = "B25001_001", #Total Housing Units
             Vacant = "B25002_003") #Vacant Units


# Define your states and counties list
fp_counties_list <- list(
  PA = c("Bucks", "Chester", "Delaware", "Montgomery", "Philadelphia"),
  NJ = c("Burlington", "Camden", "Salem", "Gloucester"),
  DE = c("New Castle"),
  MD = c("Cecil")
)

# Function to retrieve ACS data for a given state
get_state_acs <- function(state, counties) {
  get_acs(
    geography = "tract",
    variables = Variables,
    survey = "acs5",
    year = 2023,
    output = "wide",
    state = state,
    county = counties,
    geometry = TRUE
  )
}

# Apply function across all states
PhilaMSACT <- fp_counties_list %>%
  imap_dfr(~ get_state_acs(.y, .x)) %>%
  mutate(pct_vacant = (VacantE / TotHouseE) * 100)

# Inspect the combined results
head(PhilaMSACT)

# summary() provides an overview of the data
summary(PhilaMSACT)

# Lets clean up this data a little bit before we go too far
# Here we are just pulling out the columns we care about using the indexing dataframe[,c("column name","etc")]
Phila<-PhilaMSACT[c("GEOID", "NAME", "MHIE", "MHVE", "TotHouseE", "VacantE", "TotalpopE", "pct_vacant", "geometry")]
# Easy renaming of the variables
names(Phila)[names(Phila) =="MHIE"]<-"MHI"
names(Phila)[names(Phila) =="MHVE"]<-"MHV"
names(Phila)[names(Phila) =="TotalpopE"]<-"Totalpop"
names(Phila)[names(Phila)=="TotHouseE"]<-"TotHouse"
names(Phila)[names(Phila)=="VacantE"]<-"Vacant"

### Setting up the color palletes
DpalMHI<-colorQuantile(palette = "viridis", domain=Phila$MHI, n=10)
DpalMHV<-colorQuantile(palette = "RdYlBu", domain=Phila$MHV, n=10)
Dpalpop<-colorQuantile(palette = "RdBu", domain=Phila$Totalpop, n=10)
DpalTotHouse<-colorBin(palette = "Purples", domain=Phila$TotHouse, bins=9)
DpalVacant<-colorBin(palette = "inferno", reverse=T, domain=Phila$pct_vacant, bins=10, na.color = "transparent")
stnd_popup = paste(Phila$NAME, "<br>", #Pop up provides the pop up information if we were to click on the county, paste() pastes all the text together
      "Total Population: ", Phila$Totalpop, "<br>", # <br> is html code for new line.   
      "Median Household Income: ", "$", Phila$MHI, "<br>",
      "Median Home Value: ", "$", Phila$MHV, "<br>",
      "Housing Units: ", Phila$TotHouse, "<br>",
      "Percent of Total Housing Units that are Vacant: ", round(Phila$pct_vacant,1), "%")
### The Leaflet map
## Named map
## this will take awhile
Philamap<-Phila %>% # Data set you want to map and the '%>%' is a piping command which makes it keep moving forward 
  st_transform(crs = "+init=epsg:4326") %>% # Setting the projection of our simple feature spatial dataframe to match the webmapping application
  leaflet() %>%  # Leaflet function which puts this all in motion
  setView(lng = -75.16, lat = 39.95, zoom = 10)%>% # the lng and lat set the center point, while zoom chooses how zoomed in it is
  addTiles(group = "OSM (default)") %>%  #This sets the base map and the following addProviderTiles() are optional otehr basemaps
  addProviderTiles(providers$Stamen.TonerLite, group = "Toner Lite") %>%
  addProviderTiles(providers$CartoDB.Positron, group = "Carto B") %>%
  addPolygons(group = "Total", #Add polygons is how we choose what we want to map.
              popup = stnd_popup,
              stroke = FALSE,
              smoothFactor = 0,
              fillOpacity = 0.7,
              color = ~ Dpalpop(Totalpop)) %>% #Color palette or what the color scheme is.  You made these earlier and they need to match
  addLegend(position = "bottomleft", pal=Dpalpop, values= Phila$Totalpop, #Legend for this polygon layer
            title="Percentile of Census Tract Total Population", group = "Total", opacity = 1) %>% 
  addPolygons(group = "MHI", #Next layer with the same set up as before.  We could add as many as the computer would let us. 
              popup = stnd_popup,
              stroke = FALSE,
              smoothFactor = 0,
              fillOpacity = 0.7,
              color = ~ DpalMHI(MHI)) %>%
  addLegend(position = "bottomleft", pal=DpalMHI, values= Phila$MHI, 
            title="Percentile of Census Tract Median Household Income", group = "MHI", opacity = 1) %>% 
  addPolygons(group = "MHV",
              popup = stnd_popup,
              stroke = FALSE,
              smoothFactor = 0,
              fillOpacity = 0.7,
              color = ~ DpalMHV(MHV)) %>%
  addLegend(position = "bottomleft", pal=DpalMHV, values= Phila$MHV, 
            title="Percentile of Census Tract Median Household Income", group = "MHV", opacity = 1) %>%
  addPolygons(group = "TotHouse",
              popup = stnd_popup,
              stroke = FALSE,
              smoothFactor = 0,
              fillOpacity = 0.7,
              color = ~ DpalTotHouse(TotHouse)) %>%
  addLegend(position = "bottomright", pal=DpalTotHouse, values= Phila$TotHouse,
            title="Total Housing Units", group = "TotHouse", opacity = 1) %>%
  addPolygons(group = "Vacant",
              popup = stnd_popup,
              stroke = FALSE,
              smoothFactor = 0,
              fillOpacity = 0.7,
              color = ~ DpalVacant(pct_vacant)) %>%
  addLegend(position = "bottomright", pal=DpalVacant, values= Phila$pct_vacant,
            title="Percent Vacant Housing Units", group = "Vacant", opacity = 1) %>%
  # Here we hide two of the groups so that only one shows on loading
  hideGroup("TotHouse") %>%
  hideGroup("Vacant") %>%
  hideGroup("MHI") %>% # Hides the MHI layer so it doesn't all pop up at load
  hideGroup("MHV") %>% # Hides the MHV layer so it all doesn't pop up at the load

  addLayersControl(  #Gives you the option to turn on and off different basemaps or layers.
    baseGroups = c("OSM (default)", "Toner Lite", "Carto B"),
    overlayGroups = c("Total", "MHI", "MHV","TotHouse", "Vacant"),
    options = layersControlOptions(collapsed = FALSE)) 


# Saving the Html map
# first argument is the leaflet map, second is the file name and extension, and final is whether it is selfcontained
# The space needed for the self contained file is a lot which is why we reduced it down to just one layer.
saveWidget(Philamap, file="PhilaMap.html", selfcontained = T)
